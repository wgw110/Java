线程与进程
进程是指计算机上一个应用程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。在Java中，一个应用程序对应着一个JVM实例（也有地方称为JVM进程），一般来说名字默认为java.exe或者javaw.exe
一个进程包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。
线程同步
当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态
在Java中，可以通过两种方式来创建进程
第一种方式是通过Runtime.exec()方法来创建一个进程，第二种方法是通过ProcessBuilder的start方法来创建进程。
事实上通过Runtime类的exec创建进程的话，最终还是通过ProcessBuilder类的start方法来创建的，只不过Runtime类对其进行了更高一层的封装
 
对象锁概念：
其实这个对象指的是拥有synchronized修饰的函数，或者是代码块的一个类的实例。 
当某个线程访问该类的synchronized修饰的方法或代码快时，就获得该对象的锁，其他线程就无法获得该对象的锁，也就是说这个对象已经被前一个线程所占用，
另外的线程无法得到该对象，所以该对象对应的方法也就无法访问，必须等到前一个线程释放对象锁才可能有机会得到对象锁
1. java中的每个对象都有一个锁，当访问某个对象的synchronized方法时，表示将该对象上锁，此时其他任何线程都无法在去访问该syncronized 方法了，
   直到之前的那个线程执行方法完毕后，其他线程才有可能去访问该synchronized方法。
2.如果一个对象有多个synchronized方法，某一时刻某个线程已经进入到某个synchronzed方法，那么在该方法没有执行完毕前，
  其他线程无法访问该对象的任何synchronzied 方法的，但可以访问非synchronzied方法。
3.如果synchronized方法是static的，那么当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchuronized方法所在对象的对应的Class对象
  这就是类锁
java中每个对象都有一个锁，我们称之为对象锁，对象锁强调的是对于某个java对象中临界资源的占有权。如果一个线程拥有了某个对象的锁资源，那么该线程就可以占有该对象中的临界资源
并单独对该对象的临界资源进行某些操作，如果是其它线程此时也想要操作该对象的临界资源，那么其必须先取得该对象的锁资源才可以。当然占有对象锁不是说该对象的全部都会被某个线程占有
， 而是看该对象的哪些部分被标记为了临界区，一个最好的例子就是在一个对象中，如果某个方法未被synchronized修饰，则多个线程可以同时访问该这个方法。
对象锁强调的是线程对于“对象”这个资源的独占权，因为多个线程可能会涉及到对同一个对象资源的访问，这时候需要确保同一时刻有且仅有一个线程可以占用该对象资源。拥有对象锁是指拥有对对象中临界区或者是共享资源的访问。反过来说，即使没有获取对象锁，也可以访问对象的非临界区资源。
一定要清楚线程中占有的是哪个对象锁资源。比如object.wait()释放的就是object这个对象的对象锁资源
另外不同的对象锁之间是互不影响的。
 
线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）。
由于可能当前线程的任务并没有执行完毕，所以在切换时需要保存线程的运行状态，以便下次重新切换回来时能够继续切换之前的状态运行。
对于线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。
Thread类中的方法：
1）start方法
start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。
2）run方法
run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。
3）sleep方法
让当前线程休眠一段时间，但sleep方法不会让出线程锁
如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。
当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。
4）yield方法
调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，
另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。
注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。
5）join方法
等待调用join方法的线程结束后下一个线程才可以调用
比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。
t.join();      //调用join方法，等待线程t执行完毕
t.join(1000);  //等待 t 线程，等待时间是1000毫秒。
实际上调用join方法是调用了Object的wait方法。由于wait方法会让线程释放对象锁，所以join方法同样会让线程释放对一个对象持有的锁。
6）interrupt方法
interrupt，顾名思义，即中断的意思。单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程；另
外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。调用interrupt方法相当于将中断标志位置为true，调用isInterrupted()判断中断标志的
状态 
守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕
之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。

Lock机制
为何用lock机制？
1.synchronized同步机制释放锁是在线程执行完代码块或者线程发生异常导致JVM让线程释放锁，那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用
sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待
2.使用lock机制可以知道线程是否获取到锁
lock 机制与synchronized机制的区别
1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；
2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动
让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。
lock 接口
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的，unLock()方法是用来释放锁的
newCondition（）方法用于线程协作

lock机制获取锁
lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待
使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。
Lock lock = ...;
lock.lock();
try{
    //处理任务
}catch(Exception ex){
     
}finally{
    lock.unlock();   //释放锁
}
tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何
都会立即返回。在拿不到锁时不会一直在那等待。
tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，
就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。
通过tryLock来获取锁时是这样使用的：
Lock lock = ...;
if(lock.tryLock()) {
     try{
         //处理任务
     }catch(Exception ex){
         
     }finally{
         lock.unlock();   //释放锁
     } 
}else {
    //如果不能获取锁，则直接做其他事情
}
lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线
程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。
由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出
InterruptedException。
public void method() throws InterruptedException {
    lock.lockInterruptibly();
    try {  
     //.....
    }
    finally {
        lock.unlock();
    }  
}
当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。
Lock和synchronized有以下几点不同：
　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造
  成死锁现象，因此使用Lock时需要在finally块中释放锁；
　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。
　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
　　5）Lock可以提高多个线程进行读操作的效率。

1.可重入锁
可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。

在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁
同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁,这就是可重入锁
2.可中断锁
可中断锁：顾名思义，就是可以相应中断的锁。
在Java中，synchronized就不是可中断锁，而Lock是可中断锁。
如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线
程中中断它，这种就是可中断锁。
3.公平锁
公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。
在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。
而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。
在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。
我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：
ReentrantLock lock = new ReentrantLock(true);
如果参数为true表示为公平锁，为fasle为非公平锁。
4.读写锁
　读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。
　正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。
　ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。
 
volatile关键字
缓存一致性问题：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。最终结果i的值是1，而不是2。
缓存一致性协议：MESI协议核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
并发编程中的三个概念：原子性，可见性，有序性
1.原子性
　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
2.可见性
　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
3.有序性
　有序性：即程序执行的顺序按照代码的先后顺序执行。
指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同
指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性
Java内存模型：在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序
在各种平台下都能达到一致的内存访问效果
Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须
在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。
Java语言 本身对 原子性、可见性以及有序性提供了哪些保证
1.原子性
　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
2 .可见性
   普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
　 对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时,它会去内存中读取新值。
3.有序性
　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。
 
 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
　　2）禁止进行指令重排序。
volatile关键字禁止指令重排序有两层意思：
　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
 volatile的原理和实现机制
 “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”
 　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
　　2）它会强制将对缓存的修改操作立即写入主存；
　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。
 
