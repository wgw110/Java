线程与进程
进程是指计算机上一个应用程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。在Java中，一个应用程序对应着一个JVM实例（也有地方称为JVM进程），一般来说名字默认为java.exe或者javaw.exe
一个进程包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。
线程同步
当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态
在Java中，可以通过两种方式来创建进程
第一种方式是通过Runtime.exec()方法来创建一个进程，第二种方法是通过ProcessBuilder的start方法来创建进程。
事实上通过Runtime类的exec创建进程的话，最终还是通过ProcessBuilder类的start方法来创建的，只不过Runtime类对其进行了更高一层的封装
 
对象锁概念：
其实这个对象指的是拥有synchronized修饰的函数，或者是代码块的一个类的实例。 
当某个线程访问该类的synchronized修饰的方法或代码快时，就获得该对象的锁，其他线程就无法获得该对象的锁，也就是说这个对象已经被前一个线程所占用，
另外的线程无法得到该对象，所以该对象对应的方法也就无法访问，必须等到前一个线程释放对象锁才可能有机会得到对象锁
1. java中的每个对象都有一个锁，当访问某个对象的synchronized方法时，表示将该对象上锁，此时其他任何线程都无法在去访问该syncronized 方法了，
   直到之前的那个线程执行方法完毕后，其他线程才有可能去访问该synchronized方法。
2.如果一个对象有多个synchronized方法，某一时刻某个线程已经进入到某个synchronzed方法，那么在该方法没有执行完毕前，
  其他线程无法访问该对象的任何synchronzied 方法的，但可以访问非synchronzied方法。
3.如果synchronized方法是static的，那么当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchuronized方法所在对象的对应的Class对象
  这就是类锁
java中每个对象都有一个锁，我们称之为对象锁，对象锁强调的是对于某个java对象的占有权。如果一个线程拥有了某个对象的锁资源，那么该线程就可以占有该对象
并单独对该对象进行某些操作，如果是其它线程此时也想要操作该对象，那么其必须先取得该对象的锁资源才可以。当然占有对象锁不是说该对象的全部都会被某个线程占有
， 而是看该对象的哪些部分被标记为了临界区，一个最好的例子就是在一个对象中，如果某个方法未被synchronized修饰，则多个线程可以同时访问该这个方法。
对象锁强调的是线程对于“对象”这个资源的独占权，因为多个线程可能会涉及到对同一个对象资源的访问，这时候需要确保同一时刻有且仅有一个线程可以占用该对象资源。
一定要清楚线程中占有的是哪个对象锁资源。比如object.wait()释放的就是object这个对象的对象锁资源
 
线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）。
由于可能当前线程的任务并没有执行完毕，所以在切换时需要保存线程的运行状态，以便下次重新切换回来时能够继续切换之前的状态运行。
对于线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。
Thread类中的方法：
1）start方法
start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。
2）run方法
run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。
3）sleep方法
让当前线程休眠一段时间，但sleep方法不会让出线程锁
如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。
当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。
4）yield方法
调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，
另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。
注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。
5）join方法
等待调用join方法的线程结束后下一个线程才可以调用
比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。
t.join();      //调用join方法，等待线程t执行完毕
t.join(1000);  //等待 t 线程，等待时间是1000毫秒。
实际上调用join方法是调用了Object的wait方法。由于wait方法会让线程释放对象锁，所以join方法同样会让线程释放对一个对象持有的锁。
